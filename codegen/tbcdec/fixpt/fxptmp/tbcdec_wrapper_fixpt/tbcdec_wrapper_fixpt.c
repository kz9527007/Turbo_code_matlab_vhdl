/*
 * Academic License - for use in teaching, academic research, and meeting
 * course requirements at degree granting institutions only.  Not for
 * government, commercial, or other organizational use.
 *
 * tbcdec_wrapper_fixpt.c
 *
 * Code generation for function 'tbcdec_wrapper_fixpt'
 *
 */

/* Include files */
#include "mwmathutil.h"
#include "rt_nonfinite.h"
#include "tbcdec_fixpt_logger.h"
#include "tbcdec_wrapper_fixpt.h"
#include "tbcdec_fixpt.h"

/* Variable Definitions */
static emlrtRSInfo emlrtRSI = { 14,    /* lineNo */
  "tbcdec_wrapper_fixpt",              /* fcnName */
  "/home/sky/Documents/MATLAB/Turbo_codes/codegen/tbcdec/fixpt/tbcdec_wrapper_fixpt.m"/* pathName */
};

/* Function Definitions */
void tbcdec_wrapper_fixpt(const emlrtStack *sp, const real_T r1[8], const real_T
  r2[8], const real_T r3[8], real_T iter, const real_T intlv[8], real_T Lc,
  real_T dec_out[8], real_T LLR[8])
{
  int32_T i;
  real_T d0;
  real_T d1;
  int16_T b_r1[8];
  int32_T i0;
  int32_T i1;
  int16_T b_r2[8];
  int16_T b_r3[8];
  uint8_T b_intlv[8];
  int8_T dec_out_out[8];
  int16_T LLR_out[8];
  emlrtStack st;
  st.prev = sp;
  st.tls = sp->tls;

  /* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
  /*                                                                           % */
  /*            Generated by MATLAB 9.5 and Fixed-Point Designer 6.2           % */
  /*                                                                           % */
  /* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
  for (i = 0; i < 8; i++) {
    d0 = muDoubleScalarFloor(r1[i] * 2048.0);
    if (muDoubleScalarIsNaN(d0) || muDoubleScalarIsInf(d0)) {
      d0 = 0.0;
    } else {
      d0 = muDoubleScalarRem(d0, 65536.0);
    }

    if (d0 < 0.0) {
      b_r1[i] = (int16_T)-(int16_T)(uint16_T)-d0;
    } else {
      b_r1[i] = (int16_T)(uint16_T)d0;
    }

    d0 = muDoubleScalarFloor(r2[i] * 4096.0);
    if (muDoubleScalarIsNaN(d0) || muDoubleScalarIsInf(d0)) {
      d0 = 0.0;
    } else {
      d0 = muDoubleScalarRem(d0, 65536.0);
    }

    if (d0 < 0.0) {
      b_r2[i] = (int16_T)-(int16_T)(uint16_T)-d0;
    } else {
      b_r2[i] = (int16_T)(uint16_T)d0;
    }

    d0 = muDoubleScalarFloor(r3[i] * 4096.0);
    if (muDoubleScalarIsNaN(d0) || muDoubleScalarIsInf(d0)) {
      d0 = 0.0;
    } else {
      d0 = muDoubleScalarRem(d0, 65536.0);
    }

    if (d0 < 0.0) {
      b_r3[i] = (int16_T)-(int16_T)(uint16_T)-d0;
    } else {
      b_r3[i] = (int16_T)(uint16_T)d0;
    }

    d0 = muDoubleScalarFloor(intlv[i]);
    if (muDoubleScalarIsNaN(d0) || muDoubleScalarIsInf(d0)) {
      d0 = 0.0;
    } else {
      d0 = muDoubleScalarRem(d0, 256.0);
    }

    if (d0 < 0.0) {
      b_intlv[i] = (uint8_T)-(int8_T)(uint8_T)-d0;
    } else {
      b_intlv[i] = (uint8_T)d0;
    }
  }

  d0 = muDoubleScalarFloor(iter);
  if (muDoubleScalarIsNaN(d0) || muDoubleScalarIsInf(d0)) {
    d0 = 0.0;
  } else {
    d0 = muDoubleScalarRem(d0, 256.0);
  }

  d1 = muDoubleScalarFloor(Lc * 2048.0);
  if (muDoubleScalarIsNaN(d1) || muDoubleScalarIsInf(d1)) {
    d1 = 0.0;
  } else {
    d1 = muDoubleScalarRem(d1, 65536.0);
  }

  if (d0 < 0.0) {
    i0 = (uint8_T)-(int8_T)(uint8_T)-d0;
  } else {
    i0 = (uint8_T)d0;
  }

  if (d1 < 0.0) {
    i1 = (uint16_T)-(int16_T)(uint16_T)-d1;
  } else {
    i1 = (uint16_T)d1;
  }

  st.site = &emlrtRSI;
  tbcdec_fixpt(&st, b_r1, b_r2, b_r3, (uint8_T)i0, b_intlv, (uint16_T)i1,
               dec_out_out, LLR_out);
  for (i = 0; i < 8; i++) {
    dec_out[i] = dec_out_out[i];
    LLR[i] = (real_T)LLR_out[i] * 0.015625;
  }
}

/* End of code generation (tbcdec_wrapper_fixpt.c) */
